#  ES6（ECMAScript 6）

## 简介

ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 

JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。

## Babel 转码器

### 一个简单的步骤

1. 安装node

2. 安装babel

   $ npm i @babel/core @babel/cli @babel/preset-env

3. 在package.json文件中添加脚本

   "build":"babel src -d dest"

4. 创建.babelrc文件并添加配置

   {
     "presets": [
   	  "@babel/preset-env"
     ],
     "plugins": []
   }

5. 执行

   npm run build

[Babel](https://babeljs.io/) 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。

```javascript
// 转码前
input.map(item => item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
```

上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。

下面的命令在项目目录中，安装 Babel。

```bash
$ npm install --save-dev @babel/core
$ npm i @babel/core @babel/cli @babel/preset-env

core:bable核心库
core:bable必要的命令
preset-env:preset-env 会根据具体的配置编译Bable
```

### 配置文件.babelrc

Babel 的配置文件是`.babelrc`，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。

该文件用来设置转码规则和插件，基本格式如下。

```javascript
{
  "presets": [],
  "plugins": []
}
```

`presets`字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。

```bash
# 最新转码规则
$ npm install --save-dev @babel/preset-env

# react 转码规则
$ npm install --save-dev @babel/preset-react
```

然后，将这些规则加入`.babelrc`。

```javascript
  {
    "presets": [
      "@babel/env",
      "@babel/preset-react"
    ],
    "plugins": []
  }
```

注意，以下所有 Babel 工具和模块的使用，都必须先写好`.babelrc`。

### 命令行转码

Babel 提供命令行工具`@babel/cli`，用于命令行转码。

它的安装命令如下。

```bash
$ npm install --save-dev @babel/cli
```

基本用法如下。

```bash
# 转码结果输出到标准输出
$ npx babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ npx babel example.js --out-file compiled.js
# 或者
$ npx babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ npx babel src --out-dir lib
# 或者
$ npx babel src -d lib

# -s 参数生成source map文件
$ npx babel src -d lib -s
```

### babel-node

`@babel/node`模块的`babel-node`命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。

首先，安装这个模块。

```bash
$ npm install --save-dev @babel/node
```

然后，执行`babel-node`就进入 REPL 环境。

```bash
$ npx babel-node
> (x => x * 2)(1)
2
```

`babel-node`命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件`es6.js`，然后直接运行。

```bash
# es6.js 的代码
# console.log((x => x * 2)(1));
$ npx babel-node es6.js
2
```

### @babel/register 模块

`@babel/register`模块改写`require`命令，为它加上一个钩子。此后，每当使用`require`加载`.js`、`.jsx`、`.es`和`.es6`后缀名的文件，就会先用 Babel 进行转码。

```bash
$ npm install --save-dev @babel/register
```

使用时，必须首先加载`@babel/register`。

```bash
// index.js
require('@babel/register');
require('./es6.js');
```

然后，就不需要手动对`index.js`转码了。

```bash
$ node index.js
2
```

需要注意的是，`@babel/register`只会对`require`命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。

### polyfill

Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如`Iterator`、`Generator`、`Set`、`Map`、`Proxy`、`Reflect`、`Symbol`、`Promise`等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。

举例来说，ES6 在`Array`对象上新增了`Array.from`方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以使用`core-js`和`regenerator-runtime`(后者提供generator函数的转码)，为当前环境提供一个垫片。

安装命令如下。

```bash
$ npm install --save-dev core-js regenerator-runtime
```

然后，在脚本头部，加入如下两行代码。

```javascript
import 'core-js';
import 'regenerator-runtime/runtime';
// 或者
require('core-js');
require('regenerator-runtime/runtime);
```

Babel 默认不转码的 API 非常多，详细清单可以查看`babel-plugin-transform-runtime`模块的[definitions.js](https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/runtime-corejs3-definitions.js)文件。

### 浏览器环境

Babel 也可以用于浏览器环境，使用[@babel/standalone](https://babeljs.io/docs/en/next/babel-standalone.html)模块提供的浏览器版本，将其插入网页。

```html
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
// Your ES6 code
</script>
```

注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。

Babel 提供一个[REPL 在线编译器](https://babeljs.io/repl/)，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。

## let 和 const 命令

### let 命令

####  基本用法

ES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。

```javascript
{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
```

上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。

`for`循环的计数器，就很合适使用`let`命令。

```javascript
for (let i = 0; i < 10; i++) {
  // ...
}

console.log(i);
// ReferenceError: i is not defined
```

上面代码中，计数器`i`只在`for`循环体内有效，在循环体外引用就会报错。

下面的代码如果使用`var`，最后输出的是`10`。

```javascript
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```

上面代码中，变量`i`是`var`命令声明的，在全局范围内都有效，所以全局只有一个变量`i`。每一次循环，变量`i`的值都会发生改变，而循环内被赋给数组`a`的函数内部的`console.log(i)`，里面的`i`指向的就是全局的`i`。也就是说，所有数组`a`的成员里面的`i`，指向的都是同一个`i`，导致运行时输出的是最后一轮的`i`的值，也就是 10。

如果使用`let`，声明的变量仅在块级作用域内有效，最后输出的是 6。

```javascript
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```

上面代码中，变量`i`是`let`声明的，当前的`i`只在本轮循环有效，所以每一次循环的`i`其实都是一个新的变量，所以最后输出的是`6`。你可能会问，如果每一轮循环的变量`i`都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量`i`时，就在上一轮循环的基础上进行计算。

另外，`for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

上面代码正确运行，输出了 3 次`abc`。这表明函数内部的变量`i`与循环变量`i`不在同一个作用域，有各自单独的作用域。

#### 不存在变量提升

`var`命令会发生“变量提升”现象，即变量可以在声明之前使用，值为`undefined`。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

为了纠正这种现象，`let`命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

```javascript
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
```

上面代码中，变量`foo`用`var`命令声明，会发生变量提升，即脚本开始运行时，变量`foo`已经存在了，但是没有值，所以会输出`undefined`。变量`bar`用`let`命令声明，不会发生变量提升。这表示在声明它之前，变量`bar`是不存在的，这时如果用到它，就会抛出一个错误。

####  暂时性死区

只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。

```javascript
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

上面代码中，存在全局变量`tmp`，但是块级作用域内`let`又声明了一个局部变量`tmp`，导致后者绑定这个块级作用域，所以在`let`声明变量前，对`tmp`赋值会报错。

ES6 明确规定，如果区块中存在`let`和`const`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

```javascript
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```

上面代码中，在`let`命令声明变量`tmp`之前，都属于变量`tmp`的“死区”。

“暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作。

```javascript
typeof x; // ReferenceError
let x;
```

上面代码中，变量`x`使用`let`命令声明，所以在声明之前，都属于`x`的“死区”，只要用到该变量就会报错。因此，`typeof`运行时就会抛出一个`ReferenceError`。

作为比较，如果一个变量根本没有被声明，使用`typeof`反而不会报错。

```javascript
typeof undeclared_variable // "undefined"
```

上面代码中，`undeclared_variable`是一个不存在的变量名，结果返回“undefined”。所以，在没有`let`之前，`typeof`运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。

有些“死区”比较隐蔽，不太容易发现。

```javascript
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
```

上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于“死区”。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。

```javascript
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

另外，下面的代码也会报错，与`var`的行为不同。

```javascript
// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
```

上面代码报错，也是因为暂时性死区。使用`let`声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量`x`的声明语句还没有执行完成前，就去取`x`的值，导致报错”x 未定义“。

ES6 规定暂时性死区和`let`、`const`语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

#### 不允许重复声明

`let`不允许在相同作用域内，重复声明同一个变量。

```javascript
// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
```

因此，不能在函数内部重新声明参数。

```javascript
function func(arg) {
  let arg;
}
func() // 报错

function func(arg) {
  {
    let arg;
  }
}
func() // 不报错
```

#### 块级作用域

**为什么需要块级作用域？**

ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

第一种场景，内层变量可能会覆盖外层变量。

```javascript
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```

上面代码的原意是，`if`代码块的外部使用外层的`tmp`变量，内部使用内层的`tmp`变量。但是，函数`f`执行后，输出结果为`undefined`，原因在于变量提升，导致内层的`tmp`变量覆盖了外层的`tmp`变量。

第二种场景，用来计数的循环变量泄露为全局变量。

```javascript
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

上面代码中，变量`i`只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。ES6 的块级作用域

`let`实际上为 JavaScript 新增了块级作用域。

```javascript
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
```

上面的函数有两个代码块，都声明了变量`n`，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用`var`定义变量`n`，最后输出的值才是 10。

ES6 允许块级作用域的任意嵌套。

```javascript
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
```

上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。

内层作用域可以定义外层作用域的同名变量。

```javascript
{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
```

块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。

```javascript
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```

#### 块级作用域与函数声明

函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。

ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

```javascript
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
```

上面两种函数声明，根据 ES5 的规定都是非法的。

但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。

ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用。

```javascript
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
```

上面代码在 ES5 中运行，会得到“I am inside!”，因为在`if`内声明的函数`f`会被提升到函数头部，实际运行的代码如下。

```javascript
// ES5 环境
function f() { console.log('I am outside!'); }

(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
```

ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于`let`，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？

```javascript
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```

上面的代码在 ES6 浏览器中，都会报错。

原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在[附录 B](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics)里面规定，浏览器的实现可以不遵守上面的规定，有自己的[行为方式](http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6)。

- 允许在块级作用域内声明函数。
- 函数声明类似于`var`，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作`let`处理。

根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于`var`声明的变量。上面的例子实际运行的代码如下。

```javascript
// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
```

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```javascript
// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。

```javascript
// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}
```

上面代码中，第一种写法没有大括号，所以不存在块级作用域，而`let`只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。

函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。

```javascript
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```

### const 命令

#### 基本用法

`const`声明一个只读的常量。一旦声明，常量的值就不能改变。

```javascript
const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
```

上面代码表明改变常量的值会报错。

`const`声明的变量不得改变值，这意味着，`const`一旦声明变量，就必须立即初始化，不能留到以后赋值。

```javascript
const foo;
// SyntaxError: Missing initializer in const declaration
```

上面代码表示，对于`const`来说，只声明不赋值，就会报错。

`const`的作用域与`let`命令相同：只在声明所在的块级作用域内有效。

```javascript
if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
```

`const`命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

```javascript
if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
```

上面代码在常量`MAX`声明之前就调用，结果报错。

`const`声明的常量，也与`let`一样不可重复声明。

```javascript
var message = "Hello!";
let age = 25;

// 以下两行都会报错
const message = "Goodbye!";
const age = 30;
```

####  本质

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

```javascript
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

下面是另一个例子。

```javascript
const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
```

上面代码中，常量`a`是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给`a`，就会报错。

如果真的想将对象冻结，应该使用`Object.freeze`方法。

```javascript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。

```javascript
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
```

### ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：`var`命令和`function`命令。ES6 除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6 一共有 6 种声明变量的方法。

### 顶层对象的属性

顶层对象，在浏览器环境指的是`window`对象，在 Node 指的是`global`对象。ES5 之中，顶层对象的属性与全局变量是等价的。

```javascript
window.a = 1;
a // 1

a = 2;
window.a // 2
```

上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。

顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

```javascript
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```

上面代码中，全局变量`a`由`var`命令声明，所以它是顶层对象的属性；全局变量`b`由`let`命令声明，所以它不是顶层对象的属性，返回`undefined`。

### globalThis 对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

- 浏览器里面，顶层对象是`window`，但 Node 和 Web Worker 没有`window`。
- 浏览器和 Web Worker 里面，`self`也指向顶层对象，但是 Node 没有`self`。
- Node 里面，顶层对象是`global`，但其他环境都不支持。

同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用`this`变量，但是有局限性。

- 全局环境中，`this`会返回顶层对象。但是，Node 模块和 ES6 模块中，`this`返回的是当前模块。
- 函数里面的`this`，如果函数不是作为对象的方法运行，而是单纯作为函数运行，`this`会指向顶层对象。但是，严格模式下，这时`this`会返回`undefined`。
- 不管是严格模式，还是普通模式，`new Function('return this')()`，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么`eval`、`new Function`这些方法都可能无法使用。

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。

```javascript
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

[ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

垫片库[`global-this`](https://github.com/ungap/global-this)模拟了这个提案，可以在所有环境拿到`globalThis`。

## 变量的解构赋值

### 数组的解构赋值

#### 基本用法

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

以前，为变量赋值，只能直接指定值。

```javascript
let a = 1;
let b = 2;
let c = 3;
```

ES6 允许写成下面这样。

```javascript
let [a, b, c] = [1, 2, 3];
```

上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

如果解构不成功，变量的值就等于`undefined`。

```javascript
let [foo] = [];
let [bar, foo] = [1];
```

以上两种情况都属于解构不成功，`foo`的值都会等于`undefined`。

另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

```javascript
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```

上面两个例子，都属于不完全解构，但是可以成功。

如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

```javascript
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。

对于 Set 结构，也可以使用数组的解构赋值。

```javascript
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

```javascript
function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
```

上面代码中，`fibs`是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。

### 对象的解构赋值

#### 简介

解构不仅可以用于数组，还可以用于对象。

```javascript
let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"
```

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined
```

上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于`undefined`。

如果解构失败，变量的值等于`undefined`。

```javascript
let {foo} = {bar: 'baz'};
foo // undefined
```

上面代码中，等号右边的对象没有`foo`属性，所以变量`foo`取不到值，所以等于`undefined`。

对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。

```javascript
// 例一
let { log, sin, cos } = Math;

// 例二
const { log } = console;
log('hello') // hello
```

上面代码的例一将`Math`对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将`console.log`赋值到`log`变量。

如果变量名与属性名不一致，必须写成下面这样。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

上面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。

与数组一样，解构也可以用于嵌套结构的对象。

```javascript
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```

注意，这时`p`是模式，不是变量，因此不会被赋值。如果`p`也要作为变量赋值，可以写成下面这样。

```javascript
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p, p: [x, { y }] } = obj;
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
```

下面是另一个例子。

```javascript
const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

let { loc, loc: { start }, loc: { start: { line }} } = node;
line // 1
loc  // Object {start: Object}
start // Object {line: 1, column: 5}
```

上面代码有三次解构赋值，分别是对`loc`、`start`、`line`三个属性的解构赋值。注意，最后一次对`line`属性的解构赋值之中，只有`line`是变量，`loc`和`start`都是模式，不是变量。

下面是嵌套赋值的例子。

```javascript
let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
```

如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。

```javascript
// 报错
let {foo: {bar}} = {baz: 'baz'};
```

上面代码中，等号左边对象的`foo`属性，对应一个子对象。该子对象的`bar`属性，解构时会报错。原因很简单，因为`foo`这时等于`undefined`，再取子属性就会报错。

注意，对象的解构赋值可以取到继承的属性。

```javascript
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);

const { foo } = obj1;
foo // "bar"
```

上面代码中，对象`obj1`的原型对象是`obj2`。`foo`属性不是`obj1`自身的属性，而是继承自`obj2`的属性，解构赋值可以取到这个属性。

 ## 函数

### 箭头函数

**注意事项**

1. 如果有且仅有一个参数，()也可以不写

2. 如果有且仅有一个居于，并且必须是return ,{}也可以不写

**优势**

1. 简化函数编写
2. 修正this关键字

**正常情况**

```javascript
function(){
	....
}
```

**箭头函数**

```javascript
()=>{
    ....
}
```

**举例**

```javascript
function test(){
    let a = [12,2,3,1212,34,222,33];
    a.sort(
        
        (n1,n2)=>n1-n2
    
    );
    console.log(a);
}
test();
```

## 参数扩展

1. 收集，使用 ...进行参数声明，代表可变参数，除了已经声明的固定变量，不管之后传入多少参数都由使用...修饰的参数接收，接收到的格式为数组

   ```javascript
   function test(a,b,...c){
       console.log(a,b,c)
   }
   test(1,2,3,4,5,6,7)
   
   //结果:1 2 (5) [3, 4, 5, 6, 7]
   ```

2. 展开

   ```javascript
   //数组展开
   let arr1 = [1,2,3]
   let arr2 = [4,5,6]
   let arr = [...arr1,...arr2]
   console.log(arr)
   //结果:(6) [1, 2, 3, 4, 5, 6]
   
   
   //json展开
   let json = {a:1,b:2,c:3}
   let json2 = {
       ...json,
       d:5,
       e:7
   }
   console.log(json2)
   //结果:{a: 1, b: 2, c: 3, d: 5, e: 7}
   ```

## 原生对象扩展

### Array扩展：map、reduce、filter、foreach

1. map 映射：返回结果一一对应

   ```javascript
   let arr = [12,56,63,98,20]
   /* let arr2 = arr.map(function(item){
   			if(item>=60){
   				return "及格";
   			}else{
   				return "不及格";
   			}
   		}) */
   
   /* let arr2 = arr.map(function(item){
   			return item>=60?"及格":"不及格";
   		}) */
   
   let arr2 = arr.map(item=>item>=60?"及格":"不及格")
   
   console.log(arr)
   console.log(arr2)
   
   //结果
   	//arr:(5) [12, 56, 63, 98, 20]
   	//arr2:(5) ["不及格", "不及格", "及格", "及格", "不及格"]
   ```

   

2. reduce  进去n个参数 逻辑结果只有一个

   以求平均数为例

   ```javascript
   let arr = [12,56,63,98,20]
   let result = arr.reduce((tmp,item,index)=>index == arr.length-1? (tmp+item)/arr.length:tmp+item)
   console.log(result)
   ```

   

3. filter  过滤   

   ```javascript
   let arr = [12,56,63,98,20]
   		
   let resultArr = arr.filter(item=>item%2==1);
   
   console.log(resultArr)
   ```

   

4. foreach   遍历

   ```javascript
   let arr = [12,56,63,98,20]
   		
   arr.forEach((item,index)=>console.log(`第${index}个元素是${item}`))
   ```

## 异步

### Promise---封装

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="jquery.js" charset="UTF-8"></script>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		let p = new Promise(function(resolve,reject){
			//异步..
			//resolve 成功要执行的函数
			//reject 失败要执行的函数
			$.ajax({
				url:'data/1.txt',
				dataType:'json',
				success(arr){
					resolve(arr)
				},
				error(res){
					reject(res)
				}
			})
		})
		
		p.then(function resolve(arr){
			alert("成功")
			console.log(arr)
		},
		function reject(res){
			console.log(res)
		})
	</script>
</html>
```

#### Promise.all

**可执行多个ajax请求，方法内所有ajax请求必须全部成功，有一个失败结果都为失败**

```javascript
Promise.all(
    $.ajax({url:'data/1.txt',dataType:'json'}),
    $.ajax({url:'data/2.txt',dataType:'json'})
).then(arr=>{
    console.log(arr);
},res=>{
    alert("失败");
})
```

#### Promise.race

**执行多个ajax请求，哪个先成功用哪个，其他不再执行**

## async 和 await

```javascript
async function show(){
    let a = 5;
    let b = 10;

    try{
        let data = await $.ajax({url:'data/1.txt',dataType:'json'})
        console.log(a+b+data[0])
    }catch(e){
        alert('读取失败')
    }
}

show();
```

## 面向对象

### ES5面向对象

**没有专门的Class，实际是以函数的形式来写对象**

```javascript
//以函数的形式来写对象，既是类也是构造函数
function Person (name,age) {
    this.name = name;
    this.age = age;
}

//添加方法，跟类分离，方法一旦增加会很乱
Person.prototype.showName=function(){
	alert(this.name)
}

Person.prototype.showAge=function(){
	alert(this.age)
}

let p = new Person('blue',18);

p.showName();
p.showAge();

//ES5继承
function Worker(name,age,job){
    Person.call(this,name,age);
    this.job = job;
}

Worker.prototype = new Person();
Worker.prototype.constructor = Worker;

Worker.prototype.showJob=function(){
    console.log(this.job);
}

let w = new Worker('blue',18,'程序员')
w.showName();
w.showAge();
w.showJob();
```

###  ES6面向对象

使用class关键字来定义一个类，使用constructor来定义构造函数，使用extends关键字继承

```javascript
class Person{
    constructor(name,age) {
        this.name = name;
        this.age = age;
	}

	showName(){
		alert(this.name);
	}

	showAge(){
		alert(this.age);
	}
}

let p = new Person('Mr.Li',17);
p.showName();
p.showAge();

//ES6继承
class Worker extends Person{
    constructor(name,age,job) {
        super(name,age);
        this.job = job;
    }

    showJob(){
        console.log(this.job);
    }
}

let w = new Worker('blue',18,'程序员')
w.showName();
w.showAge();
w.showJob();
```



## ES6模块系统

1. 使用export导出

   export let a = 12;

   export const a =12;

   let [a,b,c] = ...;

   export {a,b,c,...}

2. 使用import导入

   import * as mod1 from 'xxx' 引入所有成员

   import mod1 from 'xxx' 引入default成员

   import {a,b as name2} from 'xxx'

   **异步引入**

   let p = import("./mod1")

3. 使用webpack编译

# VUE

## 基本使用

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<script src="./js/vue.js"></script>
	<body>
		<div id = "app">
			{{msg}}
		</div>
	</body>
	<script type="text/javascript">
		let vue = new Vue({
			el:"#app",
			data:{
				msg:"测试vue"
			}
		})
	</script>
</html>
```

1. 实例参数分析

   el：元素的挂在位置，就是将dom元素和数据进行关联

   data：数据模型

2. 插值表达式用法

   将数据填充到HTML标签中

   插值表达式支持基本的计算操作

   ```javascript
   {{1+2}}
   {{msg+'---'+123}}
   ```

## 模板语法

1. 如何理解前端渲染

   就是将数据填充到HTML页面中

### 指令

指令的本质就是自定义属性

指令格式以v-开始

####  v-cloak

插值表达式存在"闪动"问题，使用v-cloak解决，原理：先通过样式隐藏内容，在内存中进行值的替换，替换后显示最终的结果

```javascript
<style>
    [v-cloak]{
    	display:none;
    }
</style>

<div id = "app" v-cloak>
    {{msg}}
    {{1+2}}
    {{msg+'---'+123}}
</div>
```

#### v-text

无闪动问题

```javascript
<div id="appText" v-text="msg"></div>
```

#### v-html

会导致XSS攻击，不建议在第三方数据上使用，一般只在自己本网站内的数据使用

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<script src="./js/vue.js"></script>
	<body>
		<div id="appText" v-html="msg"></div>
	</body>
	<script type="text/javascript">
		
		let vue = new Vue({
			el:"#appText",
			data:{
				msg:"<h1>测试vue</h1>",
			}
		})
	</script>
</html>
```

####  v-pre

会跳过编译过程，显示原始信息

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<script src="./js/vue.js"></script>
	<body>
		<div id="appText" v-pre>{{msg}}</div>
	</body>
	<script type="text/javascript">
		
		let vue = new Vue({
			el:"#appText",
			data:{
				msg:"测试vue",
			}
		})
	</script>
</html>
```

#### v-once

只编译一次，显示内容后不再具有响应式功能

#### v-model

双向数据绑定：将数据的改变实时刷新在页面上，无需再用原生js监听改变事件

#### v-on

例如v-on:click，也可以将v-on简写为@，例如@click

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<script src="./js/vue.js"></script>
	<body>
		<div id="appText">
			<div v-text="msg"></div>
			<button @click="msg++"></button>
		</div>
	</body>
	<script type="text/javascript">
		
		let vue = new Vue({
			el:"#appText",
			data:{
				msg:2
			},
		})
	</script>
</html>
```

事件修饰符

使用.stop阻止冒泡，如果不加.stop，点击handel1方法也会触发handel，加上之后不再触发handel方法

```javascript
<div @click="handle">
	<button @click.stop="handle1"></button>
</div>
```

使用.prevent阻止默认行为，例如a标签，可阻止a标签的跳转功能

```javascript
<a href="www.baidu.com" @click.prevent="handle">跳转</a>
```

.enter回车事 .delete按键事件

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <form action="">
      <div>
        用户名：
        <input type="text" v-model='uname'>
      </div>
      <div>
        密码：
        <input type="text" @keyup.delete="clear" @keyup.enter="handleSubmit" v-model='pwd'>
      </div>
      <div>
        <input type="button" @click="handleSubmit" value="提交">
      </div>
    </form>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
    /*
      事件绑定-按键修饰符
    */
    Vue.config.keyCodes.f1 = 113
    var vm = new Vue({
      el: '#app',
      data: {
        uname: '',
        pwd: ''
      },
      methods: {
		clear:function(){
			this.pwd =''
		},
        handleSubmit: function(){
          console.log(this.uname,this.pwd)
        }
      }
    });
  </script>
</body>
</html>
```

自定义按键修饰符

```javascript
// 可以使用 `v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112
```

### 案例

简单计算器

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <h1>简单计算器</h1>
    <div>
      <span>数值A:</span>
      <span>
        <input type="text" v-model="a">
      </span>
    </div>
    <div>
      <span>数值B:</span>
      <span>
        <input type="text" v-model="b">
      </span>
    </div>
    <div>
      <button @click="result">计算</button>
    </div>
    <div>
      <span>计算结果:</span>
      <span v-text="c"></span>
    </div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				a:'',
				b:'',
				c:''
			},
			methods:{
				result:function(){
					this.c = parseInt(this.a) + parseInt(this.b)
				}
			}
		})
  </script>
</body>
</html>
```

### 属性绑定

#### v-bind

正常形式:v-bind:属性名

缩写形式:   :属性名

```javascript
<div id="app">
	  <a v-bind:href="url">百度</a>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				url:'http://www.baidu.com',
			},
			methods:{
				handle:function(){
					
				}
			}
		})
  </script>
```

### v-model原理

先使用v-bind:value指令进行值的绑定，再使用v-on:input监听改变事件，当值改变时再将属性对应的值改变，就实现了双向绑定

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	  <div v-cloak>{{value}}</div>
	  <input type="text" v-bind:value="value" v-on:input="value=$event.target.value"/>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				value:'张三'
			},
			methods:{
				
			}
		})
  </script>
</body>
</html>
```



### 样式绑定

#### class

v-bind:class="{active:isActive}"

 ```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	.active{
		background-color: red;
	}
</style>
<body>
  <div id="app">
	  <input type="text" @keyup.enter="handle" v-bind:class="{active:isActive}" v-model="value"/>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				value:'张三',
				isActive:true
			},
			methods:{
				handle:function(){
					this.isActive = !this.isActive
					this.value = ''
				}
			}
		})
  </script>
</body>
</html>

 ```

数组用法

v-bind:class="[activeArr,errorArr]"

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	.active{
		background-color: red;
	}
	.error{
		height: 100px;
	}
</style>
<body>
  <div id="app">
	<input type="text" @keyup.enter="handle" v-bind:class="[activeArr,errorArr]" v-model="value"/>
	<button @click="handle1">切换</button>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				value:'张三',
				activeArr:'active',
				errorArr:'error'
			},
			methods:{
				handle:function(){
					this.activeArr = ''
					this.value = ''
				},
				handle1:function(){
					this.activeArr ='active'
					this.value = '张三'
					this.errorArr = ''
				}
			}
		})
  </script>
</body>
</html>
```

语法细节：

1. 对象绑定和数组绑定可以结合使用

   ```javascript
   <input type="text" v-bind:class="[activeArr,errorArr,{wid:isWid}]" v-model="value"/>
   ```

   

2. class绑定的值可以简化操作

   ```javascript
   <input type="text"  v-bind:class="[classArr]" v-model="value"/>
   let vm = new Vue({
       el:'#app',
       data:{
           value:'张三',
           classArr:['active','error'],
       },
       methods:{
           
       }
   })
   ```

   

3. 默认的class如何处理

   默认的class不动，直接写上v-bind:class="[classArr]"，默认的class会被保留

   ```javascript
   <input type="text" class="base" v-bind:class="[classArr]" v-model="value"/>
   ```

#### style

基本用法

```javascript
<input type="text" v-bind:class="[classArr]" v-bind:style="[objStyle,objStyle1]" v-model="value"/>
    
let vm = new Vue({
    el:'#app',
    data:{
        value:'张三',
        classArr:['active','error'],
        objStyle:{
            border:'30px solid green',
        },
        objStyle1:{
            fontsize:'20px'
        }
    },
    methods:{
        handle:function(){
            this.objStyle.border = '10px solid blue',
                this.objStyle1.fontsize = '10px'
        }
    }
})
```

### 分支结构

#### v-if、v-else、v-else-if、v-show

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	
</style>
<body>
  <div id="app">
	<div v-if="value>=90">优秀</div>
	<div v-else-if="value>=60 && value<90">及格</div>
	<div v-else>不及格</div>
	<div v-show="isShow">
		是否显示标签v-show
	</div>
	<button @click="handle">切换</button>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				value:59,
				isShow:false
			},
			methods:{
				handle:function(){
					this.value = 100,
					this.isShow = !this.isShow
				}
			}
		})
  </script>
</body>
</html>
```

#### v-for

遍历时要加上:key=item.id，如果便利数据没有id这个属性，就使用:key=item.index，使用该属性是为了帮Vue区分不同元素，提高性能。

 ```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			[v-cloak]{
				display:none;
			}
		</style>
	</head>
	<body>
		<div>水果列表</div>
		<div id="app">
			<ul>
				<li v-for="item in fruits" v-cloak>{{item}}</li>
				<li v-for="(item,index) in fruits" v-cloak>{{item}}:{{index}}</li>
				<li :key=item.index v-for="(item,index) in myFruits" v-cloak>
					<span>{{item.ename}}:{{item.cname}}</span>
				</li>
			</ul>
		</div>
	</body>
	<script src="js/jquery.js"></script>
	<script src="js/vue.js"></script>
	<script type="text/javascript">
		let vm = new Vue({
			el:"#app",
			data:{
				fruits:['apple','banana','orange'],
				myFruits:[{
					ename:'apple',
					cname:'苹果'
				},
				{
					ename:'banana',
					cname:'香蕉'
				},
				{
					ename:'orange',
					cname:'橘子'
				}]
			},
			methods:{
				
			}
		})
	</script>
</html>
 ```

#### v-if和v-for结合使用

```javascript
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style>
			[v-cloak]{
				display:none;
			}
		</style>
	</head>
	<body>
		<div>水果列表</div>
		<div id="app">
			<ul>
				<li v-if="obj.age==12" v-for="(value,key,index) in obj" v-cloak>{{key + '---' + value + '---' + index}}</li>
			</ul>
		</div>
	</body>
	<script src="js/jquery.js"></script>
	<script src="js/vue.js"></script>
	<script type="text/javascript">
		let vm = new Vue({
			el:"#app",
			data:{
				obj:{
					name:'张三',
					age:12,
					sex:'male'
				}
	 		},
			methods:{
				
			}
		})
	</script>
</html>
```

## methods属性

可有使用$event传递事件对象，如果事件所调用方法传入参数，$event必须放在最后，可通过事件对象拿到标签任何属性和值

```javascript
let vue = new Vue({
    el:"#appText",
        data:{
        	msg:2
    	},
        methods:{
            handle:function(){
            this.msg++;
        }
    }
})
```



## 基础案例

### Tab选项卡

```javascript
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
		[v-cloak]{
			display: none;
		}
		
        .tab ul {
            overflow: hidden;
            padding: 0;
            margin: 0;
        }
        
        .tab ul li {
            box-sizing: border-box;
            padding: 0;
            float: left;
            width: 100px;
            height: 45px;
            line-height: 45px;
            list-style: none;
            text-align: center;
            border-top: 1px solid blue;
            border-right: 1px solid blue;
            cursor: pointer;
        }
        
        .tab ul li:first-child {
            border-left: 1px solid blue;
        }
        
        .tab ul li.active {
            background-color: orange;
        }
        
        .tab div {
            width: 500px;
            height: 300px;
            display: none;
            text-align: center;
            font-size: 30px;
            line-height: 300px;
            border: 1px solid blue;
            border-top: 0px;
        }
        
        .tab div.current {
            display: block;
        }
    </style>
</head>

<body>
    <div id="app">
       <div class="tab">
		   <ul>
			   <li @click="change(index)" :class="currentIndex==index?'active':''" :key="item.id" v-for="(item,index) in list" v-cloak>{{item.title}}</li>
		   </ul>
		   <div :class="currentIndex==index?'current':''" :key="item.id" v-for="(item,index) in list">
			   <img :src="item.path"/>
		   </div>
	   </div>
    </div>
    <script type="text/javascript" src="js/vue.js"></script>
    <script type="text/javascript">
       var vm = new Vue({
		   el:"#app",
		   data:{
			   currentIndex:0,
			   list:[{
				   id:1,
				   title:'apple',
				   path:'img/apple.png'
			   },
			   {
				   id:2,
				   title:'orange',
				   path:'img/orange.png'
			   },
			   {
				   id:2,
				   title:'lemon',
				   path:'img/lemon.png'
			   }]
		   },
		   methods:{
			   change:function(index){
				   this.currentIndex = index
			   }
		   }
	   })
    </script>
</body>
</html>
```



## Vue常用特性

### 表单操作

**针对select标签，可以使用multiple属性将其变为多选；提交表单时，提交按钮加上@click.prevent来组织form标签默认的提交事件，后续通过点击事件所调用的方法进行ajax提交表单**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <style type="text/css">
  
  form div {
    height: 40px;
    line-height: 40px;
  }
  form div:nth-child(4) {
    height: auto;
  }
  form div span:first-child {
    display: inline-block;
    width: 100px;
  }
  </style>
</head>
<body>
  <div id="app">
	<form action="http://www.baidu.com">
      <div>
        <span>姓名：</span>
        <span>
          <input type="text" v-model="uname">
        </span>
      </div>
      <div>
        <span>性别：</span>
        <span>
          <input type="radio" id="male" value="1" v-model="gender">
          <label for="male">男</label>
          <input type="radio" id="female" value="2" v-model="gender">
          <label for="female">女</label>
        </span>
      </div>
      <div>
        <span>爱好：</span>
        <input type="checkbox" id="ball" value="1" v-model="hobby">
        <label for="ball">篮球</label>
        <input type="checkbox" id="sing" value="2" v-model="hobby">
        <label for="sing">唱歌</label>
        <input type="checkbox" id="code" value="3" v-model="hobby">
        <label for="code">写代码</label>
      </div>
      <div>
        <span>职业：</span>
        <select v-model="occupation" multiple="true">
          <option value="0">请选择职业...</option>
          <option value="1">教师</option>
          <option value="2">软件工程师</option>
          <option value="3">律师</option>
        </select>
      </div>
      <div>
        <span>个人简介：</span>
        <textarea v-model="text"></textarea>
      </div>
      <div>
        <input type="submit" value="提交" @click.prevent="handle">
      </div>
	</form>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
    /*
      表单基本操作
    */
    var vm = new Vue({
      el: '#app',
      data: {
		uname:"李四",
		gender:1,
		hobby:[1,2],
		occupation:[1,2],
		text:"测试内容"
      },
      methods: {
		handle:function(){
			console.log(this.text)
		}
      }
    });
  </script>
</body>
</html>
```

#### 表单域修饰符

1. **v-model.number：将输入框内容转换为数字**
2. **v-model.trim：去掉输入内容的开头结尾空格**
3. **v-model.lazy：将输入框的Input事件（即输入框内容发生变化，数据模型内容就发生变化）改变为change事件（即输入框内容发生变化，只有失去焦点时数据模型内容才发生变化）**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	
</style>
<body>
  <div id="app">
	<input  type="text" v-model.number="a"/>
	<input  type="text" v-model.trim="b"/>
	<input  type="text" v-model.lazy="c" />
	<div v-cloak>{{c}}</div>
	<button @click="handle">提交</button>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		let vm = new Vue({
			el:'#app',
			data:{
				a:"",
				b:"",
				c:""
			},
			methods:{
				handle:function(){
					console.log(this.c)
				}
			}
		})
  </script>
</body>
</html>
```



### 自定义指令

**定义完成后页面使用v-focus使用**

```javascript
Vue.directive('focus',{
    inserted:function(el){
        el.focus();
    }
})
```

**带参数的自定义指令用法**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	
</style>
<body>
  <div id="app">
	<input  type="text" v-color="msg"/>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		Vue.directive('color',{
			bind:function(el,binding){
				el.style.backgroundColor = binding.value.color
			}
		})
	  
		var vm = new Vue({
			el:'#app',
			data:{
				msg:{
					color:"blue"
				}
			},
			methods:{
				handle:function(){
				}
			}
		})
  </script>
</body>
</html>
```

#### 局部自定义指令

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
	
</style>
<body>
  <div id="app">
	<input  type="text" v-color="msg" v-focus/>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
	  
		var vm = new Vue({
			el:'#app',
			data:{
				msg:{
					color:"blue"
				}
			},
			methods:{
				handle:function(){
				}
			},
			directives:{
				color:{
					bind:function(el,binding){
						el.style.backgroundColor = binding.value.color
					}
				},
				focus:{
					inserted:function(el){
						el.focus();
					}
				}
			}
		})
  </script>
</body>
</html>
```



### 计算属性

**计算属性computed是为了将复杂的运算逻辑抽取出来，让模板变的更加整洁，被调用计算方法一定要加return，不然无法将计算结果返回给模板**

**计算属性computed与方法methods的取别：**

1. **如果data属性的值不发生变化，计算属性computed内定义的方法只会在第一次被调用时执行一次，之后将结果缓存起来，再次调用时直接获取缓存的值**
2. **methods属性定义的方法不存在缓存，调用几次就执行几次**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	<div>{{msg}}</div>
	<div>{{reversedMessage}}</div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
	  
		var vm = new Vue({
			el:'#app',
			data:{
				msg:"hello"
			},
			methods:{
				handle:function(){
					
				}
			},
			computed:{
				reversedMessage:function(){
					return this.msg.split('').reverse().join('');
				}
			}
		})
  </script>
</body>
</html>

```



### 侦听器

**使用watch属性，方法名要和数据模型的名称一致，数据一旦发生变化就马上通知监听器所绑定的方法。**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	<div>
		<span>姓:</span>
		<span>
			<input type="text" v-model="firstname" />
		</span>
	</div>
	<div>
		<span>名:</span>
		<span>
			<input type="text" v-model="lastname" />
		</span>
	</div>
	<div>{{fullname}}</div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
	  
		var vm = new Vue({
			el:'#app',
			data:{
				firstname:"李",
				lastname:"昕",
				fullname:"李昕"
			},
			watch:{
				firstname:function(val){
					this.fullname = val + ' ' + this.lastname;
				},
				lastname:function(val){
					this.fullname = this.firstname + ' ' + val;
				}
			}
			
		})
  </script>
</body>
</html>
```



#### 验证用户名案例

**输入用户名，1秒后提示用户名是否可用**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	<div>
		<span>用户名:</span>
		<span>
			<input type="text" v-model.lazy="uname" />
		</span>
		<span v-cloak>{{tip}}</span>
	</div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
	  
		var vm = new Vue({
			el:'#app',
			data:{
				uname:"",
				tip:""
			},
			methods:{
				checkUname:function(uname){
					let that = this;
					setTimeout(()=>uname=='admin'?
						that.tip="用户名已存在，请重新输入":
						that.tip="用户名可用",1000)
				}
			},
			watch:{
				uname:function(val){
					this.checkUname(val);
					this.tip="正在验证....."
				}
			}
		}) 
  </script>
</body>
</html>
```

### 过滤器

**过滤器调用可在插值表达式中调用，也可在属性绑定中使用，过滤器必须提供return返回值**

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	  <input type="text" v-model="msg"/>
	   <div v-cloak>{{msg | upper}}</div>
	  <div v-cloak>{{msg | upper | lower}}</div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		Vue.filter('upper',function(val){
			return val.charAt(0).toUpperCase()+val.slice(1);
		})
		
		Vue.filter('lower',function(val){
			return val.charAt(0).toLowerCase()+val.slice(1);
		})
		
		var vm = new Vue({
			el:'#app',
			data:{
				msg:""
			}
		}) 
  </script>
</body>
</html>
```

#### 局部过滤器

**使用方法与全局过滤器一致，需在Vue实例中加入filters属性**

```javascript
	var vm = new Vue({
			el:'#app',
			data:{
				msg:""
			},
			filters:{
				upper:function(val){
					return val.charAt(0).toUpperCase()+val.slice(1);
				},
				lower:function(val){
					return val.charAt(0).toLowerCase()+val.slice(1);
				}
			}
		}) 
```

#### 带参数的过滤器

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<style>
	[v-cloak]{
		display: none;
	}
</style>
<body>
  <div id="app">
	   <div v-cloak>{{msg | format('yyyy-mm-dd')}}</div>
  </div>
  <script type="text/javascript" src="js/vue.js"></script>
  <script type="text/javascript">
		Vue.filter('format',function(value,arg){
			function dateFormat(date, format) {
			  if (typeof date === "string") {
				  var mts = date.match(/(\/Date\((\d+)\)\/)/);
				  if (mts && mts.length >= 3) {
					  date = parseInt(mts[2]);
				  }
			  }
			  date = new Date(date);
			  if (!date || date.toUTCString() == "Invalid Date") {
				  return "";
			  }
			  var map = {
				  "M": date.getMonth() + 1, //月份 
				  "d": date.getDate(), //日 
				  "h": date.getHours(), //小时 
				  "m": date.getMinutes(), //分 
				  "s": date.getSeconds(), //秒 
				  "q": Math.floor((date.getMonth() + 3) / 3), //季度 
				  "S": date.getMilliseconds() //毫秒 
			  };

			  format = format.replace(/([yMdhmsqS])+/g, function(all, t) {
				  var v = map[t];
				  if (v !== undefined) {
					  if (all.length > 1) {
						  v = '0' + v;
						  v = v.substr(v.length - 2);
					  }
					  return v;
				  } else if (t === 'y') {
					  return (date.getFullYear() + '').substr(4 - all.length);
				  }
				  return all;
			  });
			  return format;
			}
			return dateFormat(value,arg)
		})
		
		var vm = new Vue({
			el:'#app',
			data:{
				msg:new Date()
			}
		}) 
  </script>
</body>
</html>
```

### 生命周期

1. 挂载

   beforeCreate 实例初始化之后，数据观测和事件配置之前被调用

   created	在实例创建完成后被立即调用

   beforeMount	在挂载开始之前被调用

   mounted	el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子，这里将完成请后后台数据将数据绑定到模型的过程

2. 更新

   beforeUpdate	数据更新时调用，发生在虚拟Dom打补丁之前

   updated	由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后会调用该钩子

3. 销毁

   beforeDestory	实例销毁之前调用

   destoryed	实例销毁之后调用

## 综合案例

```

```



# Ant Design of Vue

# Node.js

